<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Symmetry Drawing App</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="shared.css">
    <style>
        /* App-specific overrides */
        .app {
            max-width: 1000px;
            height: auto;
            min-height: 100vh;
        }

        /* Controls toolbar */
        .controls {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-tool {
            padding: 12px 20px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-polygon {
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            color: white;
        }

        .btn-line {
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
        }

        .btn-point {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
            color: white;
        }

        .btn-clear {
            background: linear-gradient(135deg, #434343, #000000);
            color: white;
        }

        .btn.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
        }

        /* Status text */
        .status {
            color: var(--accent-1);
            text-align: center;
            font-size: 0.9rem;
            margin-bottom: 16px;
            min-height: 24px;
        }

        /* Canvas container */
        .canvas-container {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 12px;
            backdrop-filter: blur(20px);
            margin-bottom: 20px;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 12px;
            background: #f8f9fa;
        }

        /* Instructions card */
        .instructions {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(20px);
        }

        .instructions h3 {
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 12px;
            text-align: center;
        }

        .instructions p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .instructions strong {
            color: var(--text-primary);
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <div class="bg-animation"></div>

    <div class="app">
        <header class="header">
            <h1>âœ¨ Symmetry Drawing</h1>
        </header>

        <div class="controls">
            <button class="btn btn-tool btn-polygon" id="btnPolygon">Draw Polygon</button>
            <button class="btn btn-tool btn-line" id="btnLine">Draw Line</button>
            <button class="btn btn-tool btn-point" id="btnPoint">Draw Point</button>
            <button class="btn btn-tool btn-clear" id="btnClear">Clear All</button>
        </div>

        <div class="status" id="status">Select a tool to start drawing</div>

        <div class="canvas-container">
            <canvas id="canvas" width="900" height="550"></canvas>
        </div>

        <div class="instructions">
            <h3>How to Use</h3>
            <p>
                <strong>Polygon:</strong> Click to add vertices, click near first vertex to close. Drag to move.<br>
                <strong>Line:</strong> Click and drag to draw a mirror line. Drag endpoints to adjust.<br>
                <strong>Point:</strong> Click to place a mirror point. Drag to move.<br>
                The polygon will be mirrored across both the line and the point in real-time!
            </p>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #667eea;"></div>
                    <span>Original Polygon</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #f5576c;"></div>
                    <span>Line Mirror</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00f2fe;"></div>
                    <span>Point Mirror</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // State
        let currentTool = null;
        let polygon = null;          // { points: [{x, y}, ...], closed: boolean }
        let mirrorLine = null;       // { start: {x, y}, end: {x, y} }
        let mirrorPoint = null;      // { x, y }

        // Interaction state
        let isDrawing = false;
        let isDragging = false;
        let dragTarget = null;       // 'polygon', 'line-start', 'line-end', 'line', 'point'
        let dragOffset = { x: 0, y: 0 };
        let lastClick = 0;

        // Buttons
        const btnPolygon = document.getElementById('btnPolygon');
        const btnLine = document.getElementById('btnLine');
        const btnPoint = document.getElementById('btnPoint');
        const btnClear = document.getElementById('btnClear');

        // Button event listeners
        btnPolygon.addEventListener('click', () => setTool('polygon'));
        btnLine.addEventListener('click', () => setTool('line'));
        btnPoint.addEventListener('click', () => setTool('point'));
        btnClear.addEventListener('click', clearAll);

        function setTool(tool) {
            currentTool = tool;
            [btnPolygon, btnLine, btnPoint].forEach(btn => btn.classList.remove('active'));

            if (tool === 'polygon') {
                btnPolygon.classList.add('active');
                setStatus('Click to add polygon vertices, double-click to close');
            } else if (tool === 'line') {
                btnLine.classList.add('active');
                setStatus('Click and drag to draw mirror line');
            } else if (tool === 'point') {
                btnPoint.classList.add('active');
                setStatus('Click to place mirror point');
            }
        }

        function setStatus(text) {
            statusEl.textContent = text;
        }

        function clearAll() {
            polygon = null;
            mirrorLine = null;
            mirrorPoint = null;
            currentTool = null;
            [btnPolygon, btnLine, btnPoint].forEach(btn => btn.classList.remove('active'));
            setStatus('All cleared. Select a tool to start drawing');
            draw();
        }

        // Canvas event listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('dblclick', handleDoubleClick);

        // Touch support
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function getTouchPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = e.touches[0];
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        function handleTouchStart(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            handleInteractionStart(pos);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const pos = getTouchPos(e);
            handleInteractionMove(pos);
        }

        function handleTouchEnd(e) {
            handleInteractionEnd();
        }

        function distance(p1, p2) {
            return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        }

        function pointToLineDistance(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = lineStart.x;
                yy = lineStart.y;
            } else if (param > 1) {
                xx = lineEnd.x;
                yy = lineEnd.y;
            } else {
                xx = lineStart.x + param * C;
                yy = lineStart.y + param * D;
            }

            return Math.sqrt((point.x - xx) ** 2 + (point.y - yy) ** 2);
        }

        function getPolygonCenter() {
            if (!polygon || polygon.points.length === 0) return null;
            const sum = polygon.points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
            return { x: sum.x / polygon.points.length, y: sum.y / polygon.points.length };
        }

        function isPointInPolygon(point, poly) {
            if (!poly || poly.points.length < 3) return false;

            let inside = false;
            const points = poly.points;

            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                if ((points[i].y > point.y) !== (points[j].y > point.y) &&
                    point.x < (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            handleInteractionStart(pos);
        }

        function handleInteractionStart(pos) {
            // Check for dragging existing objects first
            if (mirrorPoint && distance(pos, mirrorPoint) < 15) {
                isDragging = true;
                dragTarget = 'point';
                dragOffset = { x: pos.x - mirrorPoint.x, y: pos.y - mirrorPoint.y };
                setStatus('Dragging mirror point');
                return;
            }

            if (mirrorLine) {
                if (distance(pos, mirrorLine.start) < 15) {
                    isDragging = true;
                    dragTarget = 'line-start';
                    setStatus('Dragging line start point');
                    return;
                }
                if (distance(pos, mirrorLine.end) < 15) {
                    isDragging = true;
                    dragTarget = 'line-end';
                    setStatus('Dragging line end point');
                    return;
                }
                if (pointToLineDistance(pos, mirrorLine.start, mirrorLine.end) < 10) {
                    isDragging = true;
                    dragTarget = 'line';
                    dragOffset = {
                        x: pos.x - mirrorLine.start.x,
                        y: pos.y - mirrorLine.start.y
                    };
                    setStatus('Dragging mirror line');
                    return;
                }
            }

            if (polygon && polygon.closed) {
                const center = getPolygonCenter();
                if (isPointInPolygon(pos, polygon) || distance(pos, center) < 30) {
                    isDragging = true;
                    dragTarget = 'polygon';
                    dragOffset = { x: pos.x - center.x, y: pos.y - center.y };
                    setStatus('Dragging polygon');
                    return;
                }
            }

            // Creating new objects based on current tool
            if (currentTool === 'polygon') {
                if (!polygon) {
                    polygon = { points: [pos], closed: false };
                } else if (!polygon.closed) {
                    // Check if clicking near the first point to close (touch-friendly)
                    if (polygon.points.length >= 3 && distance(pos, polygon.points[0]) < 25) {
                        polygon.closed = true;
                        setStatus('Polygon closed! Drag to move it.');
                        draw();
                        return;
                    }
                    polygon.points.push(pos);
                }
                setStatus(`Polygon: ${polygon.points.length} vertices. Click near first point or double-click to close.`);
                draw();
            } else if (currentTool === 'line') {
                isDrawing = true;
                mirrorLine = { start: { ...pos }, end: { ...pos } };
                setStatus('Drawing mirror line...');
            } else if (currentTool === 'point') {
                mirrorPoint = { ...pos };
                setStatus('Mirror point placed. Drag to move.');
                draw();
            }
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e);
            handleInteractionMove(pos);

            // Update cursor
            let cursor = 'default';
            if (mirrorPoint && distance(pos, mirrorPoint) < 15) cursor = 'move';
            if (mirrorLine) {
                if (distance(pos, mirrorLine.start) < 15 || distance(pos, mirrorLine.end) < 15) cursor = 'move';
                else if (pointToLineDistance(pos, mirrorLine.start, mirrorLine.end) < 10) cursor = 'move';
            }
            if (polygon && polygon.closed && isPointInPolygon(pos, polygon)) cursor = 'move';
            canvas.style.cursor = cursor;
        }

        function handleInteractionMove(pos) {
            if (isDrawing && currentTool === 'line') {
                mirrorLine.end = { ...pos };
                draw();
                return;
            }

            if (isDragging) {
                if (dragTarget === 'point') {
                    mirrorPoint.x = pos.x - dragOffset.x;
                    mirrorPoint.y = pos.y - dragOffset.y;
                } else if (dragTarget === 'line-start') {
                    mirrorLine.start = { ...pos };
                } else if (dragTarget === 'line-end') {
                    mirrorLine.end = { ...pos };
                } else if (dragTarget === 'line') {
                    const dx = pos.x - dragOffset.x - mirrorLine.start.x;
                    const dy = pos.y - dragOffset.y - mirrorLine.start.y;
                    mirrorLine.start.x += dx;
                    mirrorLine.start.y += dy;
                    mirrorLine.end.x += dx;
                    mirrorLine.end.y += dy;
                    dragOffset = { x: pos.x - mirrorLine.start.x, y: pos.y - mirrorLine.start.y };
                } else if (dragTarget === 'polygon') {
                    const center = getPolygonCenter();
                    const dx = pos.x - dragOffset.x - center.x;
                    const dy = pos.y - dragOffset.y - center.y;
                    polygon.points.forEach(p => {
                        p.x += dx;
                        p.y += dy;
                    });
                }
                draw();
            }
        }

        function handleMouseUp(e) {
            handleInteractionEnd();
        }

        function handleInteractionEnd() {
            if (isDrawing && currentTool === 'line') {
                isDrawing = false;
                setStatus('Mirror line created. Drag endpoints to adjust.');
            }
            if (isDragging) {
                isDragging = false;
                dragTarget = null;
                setStatus('Object moved');
            }
            draw();
        }

        function handleDoubleClick(e) {
            if (currentTool === 'polygon' && polygon && !polygon.closed && polygon.points.length >= 3) {
                polygon.closed = true;
                setStatus('Polygon closed! Drag to move it.');
                draw();
            }
        }

        // Mirror calculations
        function mirrorPointAcrossLine(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (dx * dx + dy * dy);
            const closestX = lineStart.x + t * dx;
            const closestY = lineStart.y + t * dy;
            return {
                x: 2 * closestX - point.x,
                y: 2 * closestY - point.y
            };
        }

        function mirrorPointAcrossPoint(point, center) {
            return {
                x: 2 * center.x - point.x,
                y: 2 * center.y - point.y
            };
        }

        function getMirroredPolygonAcrossLine() {
            if (!polygon || !polygon.closed || !mirrorLine) return null;
            return polygon.points.map(p => mirrorPointAcrossLine(p, mirrorLine.start, mirrorLine.end));
        }

        function getMirroredPolygonAcrossPoint() {
            if (!polygon || !polygon.closed || !mirrorPoint) return null;
            return polygon.points.map(p => mirrorPointAcrossPoint(p, mirrorPoint));
        }

        // Drawing functions
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Draw mirrored polygons first (behind original)
            const lineMirrored = getMirroredPolygonAcrossLine();
            if (lineMirrored) {
                drawPolygonShape(lineMirrored, 'rgba(245, 87, 108, 0.4)', 'rgba(245, 87, 108, 0.8)', true);
            }

            const pointMirrored = getMirroredPolygonAcrossPoint();
            if (pointMirrored) {
                drawPolygonShape(pointMirrored, 'rgba(0, 242, 254, 0.4)', 'rgba(0, 242, 254, 0.8)', true);
            }

            // Draw mirror line
            if (mirrorLine) {
                drawMirrorLine();
            }

            // Draw mirror point
            if (mirrorPoint) {
                drawMirrorPoint();
            }

            // Draw original polygon
            if (polygon) {
                drawPolygon();
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawPolygon() {
            if (polygon.points.length === 0) return;

            // Draw filled polygon if closed
            if (polygon.closed && polygon.points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
                for (let i = 1; i < polygon.points.length; i++) {
                    ctx.lineTo(polygon.points[i].x, polygon.points[i].y);
                }
                ctx.closePath();

                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.6)');
                gradient.addColorStop(1, 'rgba(118, 75, 162, 0.6)');
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw lines connecting points
            if (polygon.points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
                for (let i = 1; i < polygon.points.length; i++) {
                    ctx.lineTo(polygon.points[i].x, polygon.points[i].y);
                }
                if (!polygon.closed) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw vertices
            polygon.points.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#667eea';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawPolygonShape(points, fillColor, strokeColor, dashed = false) {
            if (points.length < 3) return;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            if (dashed) ctx.setLineDash([5, 5]);
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw vertices
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = strokeColor;
                ctx.fill();
            });
        }

        function drawMirrorLine() {
            // Extend line to canvas edges for visual effect
            const dx = mirrorLine.end.x - mirrorLine.start.x;
            const dy = mirrorLine.end.y - mirrorLine.start.y;
            const len = Math.sqrt(dx * dx + dy * dy);

            if (len > 0) {
                const extendFactor = 2000;
                const extStart = {
                    x: mirrorLine.start.x - (dx / len) * extendFactor,
                    y: mirrorLine.start.y - (dy / len) * extendFactor
                };
                const extEnd = {
                    x: mirrorLine.end.x + (dx / len) * extendFactor,
                    y: mirrorLine.end.y + (dy / len) * extendFactor
                };

                // Draw extended dashed line
                ctx.beginPath();
                ctx.moveTo(extStart.x, extStart.y);
                ctx.lineTo(extEnd.x, extEnd.y);
                ctx.strokeStyle = 'rgba(245, 87, 108, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw main line
            ctx.beginPath();
            ctx.moveTo(mirrorLine.start.x, mirrorLine.start.y);
            ctx.lineTo(mirrorLine.end.x, mirrorLine.end.y);
            ctx.strokeStyle = '#f5576c';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw endpoints
            [mirrorLine.start, mirrorLine.end].forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#f5576c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawMirrorPoint() {
            // Draw radiating circles
            for (let r = 20; r <= 60; r += 20) {
                ctx.beginPath();
                ctx.arc(mirrorPoint.x, mirrorPoint.y, r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 242, 254, ${0.3 - r * 0.003})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw main point
            ctx.beginPath();
            ctx.arc(mirrorPoint.x, mirrorPoint.y, 10, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
                mirrorPoint.x, mirrorPoint.y, 0,
                mirrorPoint.x, mirrorPoint.y, 10
            );
            gradient.addColorStop(0, '#00f2fe');
            gradient.addColorStop(1, '#4facfe');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw crosshair
            ctx.beginPath();
            ctx.moveTo(mirrorPoint.x - 15, mirrorPoint.y);
            ctx.lineTo(mirrorPoint.x + 15, mirrorPoint.y);
            ctx.moveTo(mirrorPoint.x, mirrorPoint.y - 15);
            ctx.lineTo(mirrorPoint.x, mirrorPoint.y + 15);
            ctx.strokeStyle = 'rgba(0, 242, 254, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Initial draw
        draw();
    </script>
</body>

</html>