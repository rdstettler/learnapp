<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetry Drawing App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: #eee;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-polygon {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-line {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-point {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-clear {
            background: linear-gradient(135deg, #434343 0%, #000000 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .btn.active {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
        }

        .canvas-container {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
        }

        canvas {
            background: #f8f9fa;
            display: block;
        }

        .instructions {
            color: #aaa;
            margin-top: 20px;
            text-align: center;
            max-width: 800px;
            line-height: 1.6;
        }

        .instructions h3 {
            color: #fff;
            margin-bottom: 10px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .status {
            color: #4facfe;
            margin-top: 10px;
            font-size: 14px;
            min-height: 20px;
        }
    </style>
</head>
<body>
    <h1>âœ¨ Symmetry Drawing App</h1>
    
    <div class="controls">
        <button class="btn btn-polygon" id="btnPolygon">Draw Polygon</button>
        <button class="btn btn-line" id="btnLine">Draw Line</button>
        <button class="btn btn-point" id="btnPoint">Draw Point</button>
        <button class="btn btn-clear" id="btnClear">Clear All</button>
    </div>

    <div class="status" id="status">Select a tool to start drawing</div>

    <div class="canvas-container">
        <canvas id="canvas" width="900" height="600"></canvas>
    </div>

    <div class="instructions">
        <h3>How to Use</h3>
        <p>
            <strong>Polygon:</strong> Click to add vertices, double-click to close the polygon. Drag to move.<br>
            <strong>Line:</strong> Click and drag to draw a mirror line. Drag endpoints to adjust.<br>
            <strong>Point:</strong> Click to place a mirror point. Drag to move.<br>
            The polygon will be mirrored across both the line and the point in real-time!
        </p>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #667eea;"></div>
                <span>Original Polygon</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f5576c;"></div>
                <span>Line Mirror</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00f2fe;"></div>
                <span>Point Mirror</span>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // State
        let currentTool = null;
        let polygon = null;          // { points: [{x, y}, ...], closed: boolean }
        let mirrorLine = null;       // { start: {x, y}, end: {x, y} }
        let mirrorPoint = null;      // { x, y }

        // Interaction state
        let isDrawing = false;
        let isDragging = false;
        let dragTarget = null;       // 'polygon', 'line-start', 'line-end', 'line', 'point'
        let dragOffset = { x: 0, y: 0 };
        let lastClick = 0;

        // Buttons
        const btnPolygon = document.getElementById('btnPolygon');
        const btnLine = document.getElementById('btnLine');
        const btnPoint = document.getElementById('btnPoint');
        const btnClear = document.getElementById('btnClear');

        // Button event listeners
        btnPolygon.addEventListener('click', () => setTool('polygon'));
        btnLine.addEventListener('click', () => setTool('line'));
        btnPoint.addEventListener('click', () => setTool('point'));
        btnClear.addEventListener('click', clearAll);

        function setTool(tool) {
            currentTool = tool;
            [btnPolygon, btnLine, btnPoint].forEach(btn => btn.classList.remove('active'));
            
            if (tool === 'polygon') {
                btnPolygon.classList.add('active');
                setStatus('Click to add polygon vertices, double-click to close');
            } else if (tool === 'line') {
                btnLine.classList.add('active');
                setStatus('Click and drag to draw mirror line');
            } else if (tool === 'point') {
                btnPoint.classList.add('active');
                setStatus('Click to place mirror point');
            }
        }

        function setStatus(text) {
            statusEl.textContent = text;
        }

        function clearAll() {
            polygon = null;
            mirrorLine = null;
            mirrorPoint = null;
            currentTool = null;
            [btnPolygon, btnLine, btnPoint].forEach(btn => btn.classList.remove('active'));
            setStatus('All cleared. Select a tool to start drawing');
            draw();
        }

        // Canvas event listeners
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('dblclick', handleDoubleClick);

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        function distance(p1, p2) {
            return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        }

        function pointToLineDistance(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;

            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;

            if (lenSq !== 0) param = dot / lenSq;

            let xx, yy;

            if (param < 0) {
                xx = lineStart.x;
                yy = lineStart.y;
            } else if (param > 1) {
                xx = lineEnd.x;
                yy = lineEnd.y;
            } else {
                xx = lineStart.x + param * C;
                yy = lineStart.y + param * D;
            }

            return Math.sqrt((point.x - xx) ** 2 + (point.y - yy) ** 2);
        }

        function getPolygonCenter() {
            if (!polygon || polygon.points.length === 0) return null;
            const sum = polygon.points.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
            return { x: sum.x / polygon.points.length, y: sum.y / polygon.points.length };
        }

        function isPointInPolygon(point, poly) {
            if (!poly || poly.points.length < 3) return false;
            
            let inside = false;
            const points = poly.points;
            
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                if ((points[i].y > point.y) !== (points[j].y > point.y) &&
                    point.x < (points[j].x - points[i].x) * (point.y - points[i].y) / (points[j].y - points[i].y) + points[i].x) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function handleMouseDown(e) {
            const pos = getMousePos(e);
            const now = Date.now();

            // Check for dragging existing objects first
            if (mirrorPoint && distance(pos, mirrorPoint) < 15) {
                isDragging = true;
                dragTarget = 'point';
                dragOffset = { x: pos.x - mirrorPoint.x, y: pos.y - mirrorPoint.y };
                setStatus('Dragging mirror point');
                return;
            }

            if (mirrorLine) {
                if (distance(pos, mirrorLine.start) < 15) {
                    isDragging = true;
                    dragTarget = 'line-start';
                    setStatus('Dragging line start point');
                    return;
                }
                if (distance(pos, mirrorLine.end) < 15) {
                    isDragging = true;
                    dragTarget = 'line-end';
                    setStatus('Dragging line end point');
                    return;
                }
                if (pointToLineDistance(pos, mirrorLine.start, mirrorLine.end) < 10) {
                    isDragging = true;
                    dragTarget = 'line';
                    dragOffset = { 
                        x: pos.x - mirrorLine.start.x, 
                        y: pos.y - mirrorLine.start.y 
                    };
                    setStatus('Dragging mirror line');
                    return;
                }
            }

            if (polygon && polygon.closed) {
                const center = getPolygonCenter();
                if (isPointInPolygon(pos, polygon) || distance(pos, center) < 30) {
                    isDragging = true;
                    dragTarget = 'polygon';
                    dragOffset = { x: pos.x - center.x, y: pos.y - center.y };
                    setStatus('Dragging polygon');
                    return;
                }
            }

            // Creating new objects based on current tool
            if (currentTool === 'polygon') {
                if (!polygon) {
                    polygon = { points: [pos], closed: false };
                } else if (!polygon.closed) {
                    polygon.points.push(pos);
                }
                setStatus(`Polygon: ${polygon.points.length} vertices. Double-click to close.`);
                draw();
            } else if (currentTool === 'line') {
                isDrawing = true;
                mirrorLine = { start: { ...pos }, end: { ...pos } };
                setStatus('Drawing mirror line...');
            } else if (currentTool === 'point') {
                mirrorPoint = { ...pos };
                setStatus('Mirror point placed. Drag to move.');
                draw();
            }
        }

        function handleMouseMove(e) {
            const pos = getMousePos(e);

            if (isDrawing && currentTool === 'line') {
                mirrorLine.end = { ...pos };
                draw();
                return;
            }

            if (isDragging) {
                if (dragTarget === 'point') {
                    mirrorPoint.x = pos.x - dragOffset.x;
                    mirrorPoint.y = pos.y - dragOffset.y;
                } else if (dragTarget === 'line-start') {
                    mirrorLine.start = { ...pos };
                } else if (dragTarget === 'line-end') {
                    mirrorLine.end = { ...pos };
                } else if (dragTarget === 'line') {
                    const dx = pos.x - dragOffset.x - mirrorLine.start.x;
                    const dy = pos.y - dragOffset.y - mirrorLine.start.y;
                    mirrorLine.start.x += dx;
                    mirrorLine.start.y += dy;
                    mirrorLine.end.x += dx;
                    mirrorLine.end.y += dy;
                    dragOffset = { x: pos.x - mirrorLine.start.x, y: pos.y - mirrorLine.start.y };
                } else if (dragTarget === 'polygon') {
                    const center = getPolygonCenter();
                    const dx = pos.x - dragOffset.x - center.x;
                    const dy = pos.y - dragOffset.y - center.y;
                    polygon.points.forEach(p => {
                        p.x += dx;
                        p.y += dy;
                    });
                }
                draw();
            }

            // Update cursor
            let cursor = 'default';
            if (mirrorPoint && distance(pos, mirrorPoint) < 15) cursor = 'move';
            if (mirrorLine) {
                if (distance(pos, mirrorLine.start) < 15 || distance(pos, mirrorLine.end) < 15) cursor = 'move';
                else if (pointToLineDistance(pos, mirrorLine.start, mirrorLine.end) < 10) cursor = 'move';
            }
            if (polygon && polygon.closed && isPointInPolygon(pos, polygon)) cursor = 'move';
            canvas.style.cursor = cursor;
        }

        function handleMouseUp(e) {
            if (isDrawing && currentTool === 'line') {
                isDrawing = false;
                setStatus('Mirror line created. Drag endpoints to adjust.');
            }
            if (isDragging) {
                isDragging = false;
                dragTarget = null;
                setStatus('Object moved');
            }
            draw();
        }

        function handleDoubleClick(e) {
            if (currentTool === 'polygon' && polygon && !polygon.closed && polygon.points.length >= 3) {
                polygon.closed = true;
                setStatus('Polygon closed! Drag to move it.');
                draw();
            }
        }

        // Mirror calculations
        function mirrorPointAcrossLine(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (dx * dx + dy * dy);
            const closestX = lineStart.x + t * dx;
            const closestY = lineStart.y + t * dy;
            return {
                x: 2 * closestX - point.x,
                y: 2 * closestY - point.y
            };
        }

        function mirrorPointAcrossPoint(point, center) {
            return {
                x: 2 * center.x - point.x,
                y: 2 * center.y - point.y
            };
        }

        function getMirroredPolygonAcrossLine() {
            if (!polygon || !polygon.closed || !mirrorLine) return null;
            return polygon.points.map(p => mirrorPointAcrossLine(p, mirrorLine.start, mirrorLine.end));
        }

        function getMirroredPolygonAcrossPoint() {
            if (!polygon || !polygon.closed || !mirrorPoint) return null;
            return polygon.points.map(p => mirrorPointAcrossPoint(p, mirrorPoint));
        }

        // Drawing functions
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            drawGrid();

            // Draw mirrored polygons first (behind original)
            const lineMirrored = getMirroredPolygonAcrossLine();
            if (lineMirrored) {
                drawPolygonShape(lineMirrored, 'rgba(245, 87, 108, 0.4)', 'rgba(245, 87, 108, 0.8)', true);
            }

            const pointMirrored = getMirroredPolygonAcrossPoint();
            if (pointMirrored) {
                drawPolygonShape(pointMirrored, 'rgba(0, 242, 254, 0.4)', 'rgba(0, 242, 254, 0.8)', true);
            }

            // Draw mirror line
            if (mirrorLine) {
                drawMirrorLine();
            }

            // Draw mirror point
            if (mirrorPoint) {
                drawMirrorPoint();
            }

            // Draw original polygon
            if (polygon) {
                drawPolygon();
            }
        }

        function drawGrid() {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            for (let x = 0; x <= canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }

            for (let y = 0; y <= canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawPolygon() {
            if (polygon.points.length === 0) return;

            // Draw filled polygon if closed
            if (polygon.closed && polygon.points.length >= 3) {
                ctx.beginPath();
                ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
                for (let i = 1; i < polygon.points.length; i++) {
                    ctx.lineTo(polygon.points[i].x, polygon.points[i].y);
                }
                ctx.closePath();
                
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, 'rgba(102, 126, 234, 0.6)');
                gradient.addColorStop(1, 'rgba(118, 75, 162, 0.6)');
                ctx.fillStyle = gradient;
                ctx.fill();

                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw lines connecting points
            if (polygon.points.length > 1) {
                ctx.beginPath();
                ctx.moveTo(polygon.points[0].x, polygon.points[0].y);
                for (let i = 1; i < polygon.points.length; i++) {
                    ctx.lineTo(polygon.points[i].x, polygon.points[i].y);
                }
                if (!polygon.closed) {
                    ctx.strokeStyle = '#667eea';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // Draw vertices
            polygon.points.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#667eea';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawPolygonShape(points, fillColor, strokeColor, dashed = false) {
            if (points.length < 3) return;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();

            ctx.fillStyle = fillColor;
            ctx.fill();

            if (dashed) ctx.setLineDash([5, 5]);
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw vertices
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = strokeColor;
                ctx.fill();
            });
        }

        function drawMirrorLine() {
            // Extend line to canvas edges for visual effect
            const dx = mirrorLine.end.x - mirrorLine.start.x;
            const dy = mirrorLine.end.y - mirrorLine.start.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            
            if (len > 0) {
                const extendFactor = 2000;
                const extStart = {
                    x: mirrorLine.start.x - (dx / len) * extendFactor,
                    y: mirrorLine.start.y - (dy / len) * extendFactor
                };
                const extEnd = {
                    x: mirrorLine.end.x + (dx / len) * extendFactor,
                    y: mirrorLine.end.y + (dy / len) * extendFactor
                };

                // Draw extended dashed line
                ctx.beginPath();
                ctx.moveTo(extStart.x, extStart.y);
                ctx.lineTo(extEnd.x, extEnd.y);
                ctx.strokeStyle = 'rgba(245, 87, 108, 0.3)';
                ctx.lineWidth = 1;
                ctx.setLineDash([10, 10]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw main line
            ctx.beginPath();
            ctx.moveTo(mirrorLine.start.x, mirrorLine.start.y);
            ctx.lineTo(mirrorLine.end.x, mirrorLine.end.y);
            ctx.strokeStyle = '#f5576c';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw endpoints
            [mirrorLine.start, mirrorLine.end].forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#f5576c';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        function drawMirrorPoint() {
            // Draw radiating circles
            for (let r = 20; r <= 60; r += 20) {
                ctx.beginPath();
                ctx.arc(mirrorPoint.x, mirrorPoint.y, r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(0, 242, 254, ${0.3 - r * 0.003})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw main point
            ctx.beginPath();
            ctx.arc(mirrorPoint.x, mirrorPoint.y, 10, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
                mirrorPoint.x, mirrorPoint.y, 0,
                mirrorPoint.x, mirrorPoint.y, 10
            );
            gradient.addColorStop(0, '#00f2fe');
            gradient.addColorStop(1, '#4facfe');
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw crosshair
            ctx.beginPath();
            ctx.moveTo(mirrorPoint.x - 15, mirrorPoint.y);
            ctx.lineTo(mirrorPoint.x + 15, mirrorPoint.y);
            ctx.moveTo(mirrorPoint.x, mirrorPoint.y - 15);
            ctx.lineTo(mirrorPoint.x, mirrorPoint.y + 15);
            ctx.strokeStyle = 'rgba(0, 242, 254, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // Initial draw
        draw();
    </script>
</body>
</html>
